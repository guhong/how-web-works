# How Web Works

当我们在浏览器中输入 baidu.com 时，背后发生了什么呢？

**目录**

- [How Web Works](#how-web-works)
  - [当你刚输入baidu的b字母时](#当你刚输入baidu的b字母时)
  - [当你按下“Enter”键时](#当你按下enter键时)
  - [分析 URL](#分析-url)
  - [DNS 查找](#dns-查找)
  - [建立套接字 + TLS 握手](#建立套接字--tls-握手)
  - [HTTP协议](#http协议)
  - [HTTP服务器请求句柄](#http服务器请求句柄)
  - [服务器响应](#服务器响应)
  - [浏览器的背后](#浏览器的背后)
  - [浏览器的高层结构](#浏览器的高层结构)
  - [渲染引擎](#渲染引擎)
  - [主要流程](#主要流程)
  - [解析基础](#解析基础)
  - [DOM 树](#dom-树)
    - [为什么DOM速度慢？](#为什么dom速度慢)
  - [渲染树](#渲染树)
  - [渲染树与DOM树的关系](#渲染树与dom树的关系)
  - [CSS 解析](#css-解析)
  - [布局](#布局)
  - [绘画](#绘画)
  - [相关资料](#相关资料)
    - [网络的诞生](#网络的诞生)

## 当你刚输入baidu的b字母时

当你在浏览器输入b键的时候，浏览器输入栏接收到信息后就开始启动自动补全机制，根据你使用的浏览器的算法，以及你是否处于隐私模式或无痕浏览模式，浏览器会在地址栏下方的下拉列表中为你呈现各种建议。这些算法中的大多数会基于搜索历史和书签来优先推荐结果。虽然你打算输入的是“baidu.com”，这些建议似乎并不重要，但在你完成输入之前，大量代码已经在后台运行，并根据你每次按键来优化这些建议。甚至在你完全输入之前，浏览器就可能已经建议你输入“baidu.com”了。

## 当你按下“Enter”键时

按下键盘上的Enter键，敲击其范围的底部。此时，回车键专用的电路闭合（直接闭合或电容闭合）。这允许少量电流流入键盘的逻辑电路，该逻辑电路扫描每个键开关的状态，消除开关的快速间歇闭合的电噪声，并将其转换为键码整数，在这种情况下为13。键盘控制器然后对键代码进行编码，以便传输到计算机。现在，这几乎是通过通用串行总线（USB）或蓝牙连接实现的。

如果是USB键盘：
* 生成的键代码由内部键盘电路存储器存储在一个名为“端点”的寄存器中。
* 主机USB控制器每隔约10ms轮询一次该“端点”，因此它会获得存储在其上的密钥代码值。
* 该值进入以1.5 Mb/s（USB 2.0）的最大速度发送的USB SIE（串行接口引擎）。
* 然后，该串行信号在计算机的主机USB控制器处被解码，并由计算机的人机接口设备（HID）通用键盘设备驱动程序进行解释。
* 然后，密钥的值被传递到操作系统的硬件抽象层。

对于触摸屏键盘：
* 当用户将手指放在现代电容式触摸屏上时，少量电流会转移到手指上。这通过导电层的静电场完成电路，并在屏幕上的该点产生电压降。屏幕控制器随后引发一个中断，报告“点击”的坐标。
* 然后，移动操作系统在其GUI元素之一（现在是虚拟键盘应用程序按钮）中向当前关注的应用程序通知点击事件。
* 虚拟键盘现在可以引发软件中断，以便将“按键”消息发送回操作系统。
* 此中断会将“按键按下”事件通知当前关注的应用程序。

## 分析 URL

浏览器地址栏中的URL，叫做统一资源定位器，其中包含以下信息：
* 协议“http”：使用“超文本传输协议”
* 资源“/”：检索主（索引）页
当没有提供协议或有效域名时，浏览器会将地址框中的文本输入到浏览器的默认网络搜索引擎。

## DNS 查找

浏览器试图找出域名的IP地址。DNS查找过程如下：

* 浏览器缓存：浏览器缓存DNS记录一段时间。但是操作系统并没有告诉浏览器每个DNS记录的生存时间，因此浏览器会将它们缓存一段固定的时间（不同浏览器的缓存时间不同，为2-30分钟）。
* 操作系统缓存：如果浏览器缓存不包含所需的记录，浏览器将进行系统调用（在Windows中为gethostbyname）。操作系统都有自己的缓存。
* 路由器缓存：请求继续到您的路由器，该路由器通常有自己的DNS缓存。
* ISP DNS缓存：下一个检查的位置是缓存ISP的DNS服务器。当然也有缓存。
* 递归搜索：ISP的DNS服务器开始递归搜索，从根名称服务器，通过.com顶级名称服务器，通常，DNS服务器的缓存中会有.com名称服务器的名称，因此不需要访问根名称服务器。

以下是递归DNS搜索的示意图：
<p align="center">
  <img src="img/Example_of_an_iterative_DNS_resolver.svg" alt="Recursive DNS search"/>
</p>

DNS的一个令人担忧的问题是，整个域名像wikipedia.org或facebook.com似乎映射到一个单一的IP地址。幸运的是，有几种方法可以减轻这个瓶颈：

- **轮询DNS** 是一种解决方案，其中DNS查找返回多个IP地址，而不仅仅是一个。例如，facebook.com实际上映射到四个IP地址。
- **负载均衡器** 是监听特定IP地址并将请求转发到其他服务器的硬件。主要网站通常会使用昂贵的高性能负载均衡器。
- **地理DNS** 通过将域名映射到不同的IP地址，根据客户端的地理位置来提高可扩展性。这对于托管静态内容非常有用，这样不同的服务器就不必更新共享状态。
- **Anycast** 是一种路由技术，其中单个IP地址映射到多个物理服务器。不幸的是，Anycast与TCP不太匹配，在这种情况下很少使用。

大多数DNS服务器本身都使用Anycast来实现DNS查找的高可用性和低延迟。Anycast服务的用户（DNS是一个很好的例子）将始终连接到“最近”的（从路由协议角度来看）DNS服务器。这降低了延迟，并提供了一定程度的负载均衡（假设您的消费者在网络中均匀分布）。


## 建立套接字 + TLS 握手

* 当浏览器收到目标服务器的IP地址后，它会从URL中获取给定的端口号（HTTP协议默认端口为80，HTTPS默认端口为443），然后调用系统库函数socket，请求一个TCP套接字流。
* 客户端计算机向服务器发送一个ClientHello消息，其中包含其TLS版本、可用的加密算法列表和压缩方法。
* 服务器向客户端回复一个ServerHello消息，其中包含TLS版本、选定的加密算法、选定的压缩方法以及由CA（证书颁发机构）签名的服务器公钥证书。该证书包含一个由客户端用于加密握手余下部分的公钥，直到可以达成对称密钥为止。
* 客户端将服务器数字证书与其信任的CA列表进行验证。如果可以基于CA建立信任，客户端将生成一串伪随机字节并使用服务器的公钥加密此字符串。这些随机字节可以用于确定对称密钥。
* 服务器使用其私钥解密随机字节，并使用这些字节生成自己的对称主密钥。
* 客户端向服务器发送一个Finished消息，使用对称密钥加密传输至此点的哈希值。
* 服务器生成自己的哈希值，然后解密客户端发送的哈希值以验证是否匹配。如果匹配，则服务器也使用对称密钥向客户端发送自己的Finished消息。
* 从现在开始，TLS会话将使用协商好的对称密钥加密应用（HTTP）数据。


## HTTP协议

像Facebook/Gmail这样的动态网站不会从浏览器缓存中提供服务，因为动态页面的过期时间非常快，或者立即过期（到期日期被设置为过去）。

如果使用的是由谷歌编写的网络浏览器，那么它发送的不是HTTP请求来检索页面，而是发送一个请求，尝试与服务器协商从HTTP升级到SPDY协议。请注意，SPDY正在被HTTP/2所取代，最新版本的Chrome中已经不再支持SPDY。

GET请求命名要获取的URL：“[http://www.baidu.com/](http://www.baidu.com/)”。浏览器标识自身（User-Agent标头），并声明它将接受哪些类型的响应（Accept和Accept-Encoding标头）。Connection标头要求服务器保持TCP连接以供进一步请求使用。

请求还包含浏览器对此域的cookie。你可能已经知道，cookie是跟踪网站在不同页面请求之间状态的键值对。因此，cookie存储了登录用户的名称、服务器分配给用户的秘密数字、用户的一些设置等。cookie将被存储在客户端的文本文件中，并随每个请求发送到服务器。

HTTP/1.1为发送方定义了“close”连接选项，以指示在响应完成后将关闭连接。例如，Connection: close。

发送请求和标头后，网络浏览器向服务器发送一个空白的新行，表示请求的内容已完成。服务器以响应代码响应，指示请求的状态，并以以下形式的响应响应：“**200 OK [响应标头]**”

接着是一个空白行，然后发送www.baidu.com的HTML内容的有效载荷。服务器可以关闭连接，或者如果客户端发送的标头要求保持连接，则保持连接以供进一步请求重用。

如果网络浏览器发送的HTTP标头包含足够的信息，以便Web服务器确定Web浏览器缓存的文件版本自上次检索以来是否未修改（即，如果Web浏览器包含ETag标头），则它可能会以以下形式的请求作出响应：**304 Not Modified [响应标头]**，没有有效载荷，而是从其缓存中检索HTML。

解析HTML后，网络浏览器（和服务器）为HTML页面引用的每个资源（图像、CSS、favicon.ico等）重复此过程，但请求将是**GET /$(URL相对于www.baidu.com) HTTP/1.1。**

如果HTML引用了位于www.baidu.com之外的域的资源，则网络浏览器将返回到解析其他域名所涉及的步骤，并按照该域名的所有步骤跟随到目前为止的所有步骤。请求中的Host标头将设置为适当的服务器名称，而不是baidu.com。

**注意：**
URL “[http://facebook.com/](http://facebook.com/)”中的末尾斜杠很重要。在这种情况下，浏览器可以安全地添加斜杠。对于形式为http://example.com/folderOrFile的URL，浏览器不能自动添加斜杠，因为无法确定folderOrFile是文件夹还是文件。在这种情况下，浏览器将访问没有斜杠的URL，服务器将以重定向方式响应，导致不必要的往返。

服务器可能会响应301永久重定向响应，告诉浏览器转到“[http://www.baidu.com/](http://www.baidu.com/)”而不是“[http://baidu.com/](http://baidu.com/)”。服务器坚持重定向的原因有趣。其中一个原因与搜索引擎排名有关。看，如果同一个页面有两个URL，例如http://www.vasanth.com/和http://vasanth.com/，搜索引擎可能认为它们是两个不同的站点，每个站点的入站链接较少，因此排名较低。搜索引擎理解永久重定向（301），并将来自两个来源的入站链接合并到单个排名中。此外，相同内容的多个URL对缓存不友好。当内容具有多个名称时，它将在缓存中出现多次。

**注意：**
HTTP响应从服务器返回的状态代码开始。以下是状态代码的非常简要摘要：
* 1xx仅表示信息消息
* 2xx表示某种成功
* 3xx将客户端重定向到另一个URL
* 4xx表示客户端出现错误
* 5xx表示服务器出现错误

## HTTP服务器请求句柄

HTTPD（HTTP守护进程）服务器是服务器端处理请求/响应的程序。最常见的HTTPD服务器是Linux上的Apache或nginx，以及Windows上的IIS。

- HTTPD（HTTP守护进程）接收请求。
- 服务器将请求分解为以下参数：
   - HTTP请求方法（可以是GET、POST、HEAD、PUT和DELETE）。如果在地址栏直接输入URL，则为GET。
   - 域名，在这种情况下是baidu.com。
   - 请求的路径/页面，在这种情况下是/（因为没有请求特定的路径/页面，/是默认路径）。
   - 服务器验证服务器上是否配置了与baidu.com对应的虚拟主机。

- 服务器验证baidu.com是否可以接受GET请求。

- 服务器验证客户端是否允许使用此方法（通过IP、身份验证等）。

- 如果服务器安装了重写模块（如Apache的mod_rewrite或IIS的URL重写），它会尝试将请求与配置的规则之一匹配。如果找到匹配的规则，服务器将使用该规则重写请求。

- 服务器获取与请求相对应的内容，对于我们的情况，它将回退到索引文件，因为“/”是主文件（某些情况可能会覆盖此设置，但这是最常见的方法）。

- 服务器根据请求处理程序解析文件。请求处理程序是一个程序（在ASP.NET、PHP、Ruby等中），它读取请求并生成响应的HTML。如果baidu正在运行PHP，服务器将使用PHP解释索引文件，并将输出流发送给客户端。

注意：每个动态网站面临的一个有趣困难是如何存储数据。规模较小的站点通常会有一个单独的SQL数据库来存储它们的数据，但存储大量数据和/或有许多访问者的站点必须找到一种将数据库分割成多个机器的方法。解决方案包括分片（根据主键将表分割成多个数据库）、复制和使用具有弱一致性语义的简化数据库。

## 服务器响应
以下是服务器生成并发送的响应：

```txt
HTTP/1.1 200 OK
Cache-Control: private, no-store, no-cache, must-revalidate, post-check=0,
    pre-check=0
Expires: Sat, 01 Jan 2000 00:00:00 GMT
P3P: CP="DSP LAW"
Pragma: no-cache
Content-Encoding: gzip
Content-Type: text/html; charset=utf-8
X-Cnection: close
Transfer-Encoding: chunked
Date: Fri, 12 Feb 2010 09:05:55 GMT

2b3
��������T�n�@����[...]
```

整个响应大小为36 KB，其中大部分位于我截取的字节块末尾的字节blob中。

**Content-Encoding** 头告诉浏览器响应正文使用gzip算法进行了压缩。解压缩blob后，您将看到预期的HTML内容：

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
      lang="en" id="baidu" class=" no_js">
<head>
<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-language" content="en" />
...
```

注意设置Content-Type为text/html的标头。该标头指示浏览器将响应内容解释为HTML，而不是下载为文件。浏览器将使用该标头来决定如何解释响应，但也会考虑其他因素，比如URL的扩展名。

## 浏览器的背后

一旦服务器向浏览器提供资源（HTML、CSS、JS、图像等），它将经历以下过程：
* 解析 - HTML、CSS、JS
* 渲染 - 构建DOM树 → 渲染树 → 渲染树的布局 → 绘制渲染树

## 浏览器的高层结构

1. **用户界面：** 包括地址栏、后退/前进按钮、书签菜单等。除了显示请求页面的窗口外，浏览器显示的每个部分都属于用户界面。

2. **浏览器引擎：** 在用户界面和渲染引擎之间调度操作。

3. **渲染引擎：** 负责显示请求的内容。例如，渲染引擎解析HTML和CSS，并在屏幕上显示解析后的内容。

4. **网络：** 用于网络调用，例如HTTP请求，使用不同平台的不同实现（在一个平台独立的接口后面）。

5. **UI后端：** 用于绘制基本的小部件，如下拉框和窗口。此后端暴露一个通用接口，不是特定于平台的。在底层，它使用操作系统的用户界面方法。

6. **JavaScript引擎：** 用于解析和执行JavaScript代码的解释器。

7. **数据存储：** 这是一个持久化层。浏览器可能需要在本地保存数据，例如cookie。浏览器还支持诸如 [localStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage)、[IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB) 和 [FileSystem](https://developer.chrome.com/apps/fileSystem) 等存储机制。

让我们从最简单的情况开始：一个简单的HTML页面，其中包含一些文本和一个图像。浏览器处理这个简单页面需要做什么？

1. **转换：** 浏览器从磁盘或网络读取HTML的原始字节，并根据文件的指定编码（例如UTF-8）将它们转换为单个字符。

2. **标记化：** 浏览器将字符串转换为W3C HTML5标准指定的不同标记（例如“<html>”、“<body>”以及在“尖括号”内的其他字符串）。每个标记都有特殊的含义和一组规则。

3. **词法分析：** 生成的标记被转换为定义它们属性和规则的“对象”。

4. **DOM构建：** 最后，由于HTML标记定义了不同标签之间的关系（一些标签包含在标签内），所以创建的对象被链接在树形数据结构中，该结构还捕获了原始标记中定义的父子关系：HTML对象是body对象的父对象，body是段落对象的父对象，依此类推。

这个过程的最终输出是文档对象模型，或我们简单页面的“DOM”，浏览器将其用于页面的所有后续处理。

每当浏览器必须处理HTML标记时，它都必须经过上述所有步骤：将字节转换为字符，识别标记，将标记转换为节点，并构建DOM树。整个过程可能需要一些时间，特别是如果要处理大量HTML时。

如果您打开Chrome DevTools并在加载页面时记录时间轴，您可以看到执行此步骤所需的实际时间 - 在上面的示例中，将HTML字节块转换为DOM树大约花费了~5ms。当然，如果页面更大，像大多数页面一样，这个过程可能会花费更长的时间。在我们后面关于创建流畅动画的部分中，您将看到如果浏览器必须处理大量HTML，这很容易成为您的瓶颈。

## 渲染引擎

渲染引擎是一种软件组件，它接收标记内容（例如HTML、XML、图像文件等）和格式化信息（例如CSS、XSL等），并在屏幕上显示格式化的内容。

|浏览器             |引擎                           |
|------------------|:----------------------------:|
|Chrome            | Blink（WebKit的一个分支）      |
|Firefox           | Gecko                        |
|Safari            | Webkit                       |
|Opera             | Blink（小于v15时为Presto）    |
|Internet Explorer | Trident                      |
|Edge              | Blink（小于v79时为EdgeHTML）  |

WebKit是一个开源的渲染引擎，最初作为Linux平台的引擎，由Apple修改以支持Mac和Windows。

渲染引擎是单线程的。除了网络操作外，几乎所有操作都在单个线程中进行。在Firefox和Safari中，这是浏览器的主线程。在Chrome中，这是标签进程的主线程。
网络操作可以由多个并行线程执行。并行连接的数量是有限的（通常每个主机名限制6-13个连接）。

浏览器的主线程是一个事件循环。它是一个无限循环，保持进程处于活动状态。它等待事件（如布局和绘制事件）并处理它们。

注意：诸如Chrome之类的浏览器运行多个渲染引擎实例：每个标签一个。每个标签在单独的进程中运行。

## 主要流程

渲染引擎将开始从网络层获取请求文档的内容。这通常以8KB的块为单位进行。

在那之后，渲染引擎的基本流程如下：

<p align="center">
  <img src="img/flow.png" alt="Rendering engine basic flow"/>
</p>

渲染引擎将开始解析HTML文档，并将元素转换为名为“内容树”的树中的[DOM](http://domenlightenment.com/)节点。

引擎将解析样式数据，包括外部CSS文件和样式元素中的样式。样式信息与HTML中的视觉指令一起用于创建另一个树：**渲染树**。
渲染树包含具有颜色和尺寸等视觉属性的矩形。这些矩形按照正确的顺序排列，以在屏幕上显示。

在构建渲染树之后，它经历一个**“布局”**过程。这意味着为每个节点提供其应出现在屏幕上的确切坐标。

下一个阶段是**绘制**-渲染树将被遍历，并使用UI后端层对每个节点进行绘制。

重要的是要理解这是一个逐步进行的过程。为了提供更好的用户体验，渲染引擎将尝试尽快在屏幕上显示内容。它不会等待所有HTML被解析后再开始构建和布局渲染树。部分内容将被解析和显示，同时进程继续处理从网络中不断到来的其余内容。

以下是Webkit的流程图：

<p align="center">
  <img src="img/webkitflow.png" alt="Webkit main flow"/>
</p>

## 解析基础

**解析：** 将文档转换为代码可以使用的结构。解析的结果通常是表示文档结构的节点树。

**语法：** 解析基于文档遵循的语法规则：它所写的语言或格式。您可以解析的每种格式都必须具有确定性的语法，由词汇和语法规则组成。它被称为**上下文无关文法**。

解析可以分为两个子过程：词法分析和语法分析。

**词法分析：** 将输入分解为标记的过程。标记是语言的词汇：有效构建块的集合。

**语法分析：** 应用语言的语法规则。

解析器通常将工作分配给两个组件：词法分析器（有时称为标记器），负责将输入分解为有效标记；解析器负责根据语言语法规则分析文档结构并构造解析树。词法分析器知道如何剥离不相关的字符，如空格和换行符。

解析过程是迭代的。解析器通常会向词法分析器请求一个新的标记，并尝试将标记与语法规则中的一个进行匹配。如果匹配了规则，将会向解析树添加一个对应于标记的节点，然后解析器会请求另一个标记。

如果没有规则与之匹配，解析器会将标记存储在内部，并继续请求标记，直到找到与所有内部存储的标记都匹配的规则。如果找不到规则，则解析器会引发异常。这意味着文档无效，包含语法错误。

HTML解析器的任务是将HTML标记解析成解析树。HTML定义采用DTD（文档类型定义）格式。这种格式用于定义SGML系列语言。该格式包含所有允许元素、它们的属性和层次结构的定义。正如我们之前看到的，HTML DTD不构成上下文无关文法。

HTML解析算法包括两个阶段：标记化和树构建。

**标记化** 是词法分析，将输入解析为标记。在HTML中，标记包括开始标记、结束标记、属性名和属性值。标记器识别标记，将其传递给树构造器，并消耗下一个字符以识别下一个标记，依此类推直到输入结束。

<p align="center">
  <img src="img/image017.png" alt="HTML parsing flow"/>
</p>

## DOM 树

输出树（“解析树”）是DOM元素和属性节点的树。DOM是文档对象模型的简称。它是HTML文档的对象表示形式，也是HTML元素与JavaScript等外部世界的接口。树的根是“文档”对象。

DOM与标记几乎是一对一的关系。例如：

```html
<html>
  <body>
    <p>
      Hello World
    </p>
    <div> <img src="example.png"/></div>
  </body>
</html>
```

这个标记将被转换为以下DOM树：

<p align="center">
  <img src="img/image015.png" alt="DOM Tree"/>
</p>

### 为什么DOM速度慢？

简短的答案是，DOM并不慢。添加和删除DOM节点只是一些指针交换，几乎和在JS对象上设置属性一样。

然而，布局是慢的。当您以任何方式触摸DOM时，会在整个树上设置一个脏位，告诉浏览器它需要重新确定所有元素的位置。当JS将控制权交还给浏览器时，它会调用其布局算法（更准确地说，它会调用其CSS重新计算算法，然后布局，然后重绘，然后重新合成）来重新绘制屏幕。布局算法非常复杂 - 阅读CSS规范以了解一些规则 - 这意味着它经常必须做出非局部的决定。

更糟糕的是，布局会由访问某些属性触发同步执行。其中包括getComputedStyleValue()、getBoundingClientWidth()、.offsetWidth、.offsetHeight等，这使得它们极易被触发。完整列表请参阅[此处](https://gist.github.com/paulirish/5d52fb081b3570c81e3a)。
因此，许多Angular和JQuery代码运行缓慢。在移动设备上，一个布局可能会耗尽整个帧的预算。
React并不能加速布局 - 如果您希望在移动web浏览器上获得丝滑的动画效果，您需要采取其他技术，例如限制每帧中的所有操作都可以在GPU上执行。但是，它确保在更新页面状态时最多执行一次布局。这通常是对现状的一种改进。

## 渲染树

在构建DOM树的同时，浏览器还会构建另一个树，即渲染树。该树是按照它们将被显示的顺序排列的视觉元素。它是文档的视觉表示。这个树的目的是以正确的顺序绘制内容。

渲染器知道如何布局和绘制自身及其子元素。每个渲染器代表一个矩形区域，通常对应于节点的CSS框。

## 渲染树与DOM树的关系

渲染器对应于DOM元素，但二者的关系并非一一对应。非可视的DOM元素不会被插入到渲染树中。例如，"head"元素就是一个例子。同时，那些显示值被指定为"none"的元素也不会出现在树中（而具有"hidden"可见性的元素将出现在树中）。

有些DOM元素对应于多个视觉对象。这些通常是具有复杂结构的元素，无法用单个矩形来描述。例如，"select"元素有三个渲染器：一个用于显示区域，一个用于下拉列表框，一个用于按钮。另外，当文本被分成多行因为宽度不足以容纳一行时，新的行将作为额外的渲染器添加。

一些渲染对象对应于一个DOM节点，但不在树的同一位置。浮动和绝对定位的元素是超出流动的，它们放置在树的不同部分，并映射到真实的框架。占位框是它们应该存在的地方。

<p align="center">
  <img src="img/image025.png" alt="The render tree and the corresponding DOM tree"/>
</p>

在WebKit中，解析样式并创建渲染器的过程称为"attachment"。每个DOM节点都有一个"attach"方法。附加是同步的，将节点插入DOM树时会调用新节点的"attach"方法。

构建渲染树需要计算每个渲染对象的视觉属性。这是通过计算每个元素的样式属性来实现的。样式包括各种来源的样式表、内联样式元素和HTML中的视觉属性（例如"bgcolor"属性）。后者被转换为匹配的CSS样式属性。

## CSS 解析

CSS选择器在浏览器引擎中是从右向左匹配的。请记住，在浏览器执行选择器匹配时，它有一个元素（正在确定样式的元素）以及所有规则和它们的选择器，需要找到哪些规则与该元素匹配。这与通常的jQuery方式不同，例如，您只有一个选择器，需要找到所有与该选择器匹配的元素。

选择器的特异性计算如下：

- 如果声明来自于“style”属性而不是带有选择器的规则，则计数为1，否则为0（= a）
- 计算选择器中ID选择器的数量（= b）
- 计算选择器中的类选择器、属性选择器和伪类的数量（= c）
- 计算选择器中元素名称和伪元素的数量（= d）
- 忽略通配选择器

将这三个数字a-b-c-d（在一个较大的进位制数系统中）连接起来得到特异性。您需要使用的进位制数是由a、b、c和d中最高的计数来定义的。

例如：

``` txt
*               /* a=0 b=0 c=0 -> specificity =   0 */
LI              /* a=0 b=0 c=1 -> specificity =   1 */
UL LI           /* a=0 b=0 c=2 -> specificity =   2 */
UL OL+LI        /* a=0 b=0 c=3 -> specificity =   3 */
H1 + *[REL=up]  /* a=0 b=1 c=1 -> specificity =  11 */
UL OL LI.red    /* a=0 b=1 c=3 -> specificity =  13 */
LI.red.level    /* a=0 b=2 c=1 -> specificity =  21 */
#x34y           /* a=1 b=0 c=0 -> specificity = 100 */
#s12:not(FOO)   /* a=1 b=0 c=1 -> specificity = 101 */
```

CSSOM具有树结构的原因是什么？当计算页面上任何对象的最终样式集时，浏览器从适用于该节点的最通用规则开始（例如，如果它是body元素的子元素，则所有body样式都适用），然后通过递归地应用更具体的规则来细化计算样式 - 即规则“级联”。

WebKit使用一个标志来标记是否已加载所有顶级样式表（包括@imports）。如果在附加时样式尚未完全加载，则使用占位符，并在文档中标记，一旦样式表加载完成，它们将被重新计算。

## 布局

当渲染器被创建并添加到树中时，它没有位置和大小。计算这些值称为布局或回流。

HTML使用基于流的布局模型，这意味着大多数情况下可以在单次遍历中计算几何信息。流后面的元素通常不会影响流前面的元素的几何信息，因此布局可以通过文档从左到右，从上到下进行。坐标系相对于根框架。使用顶部和左侧坐标。

布局是一个递归过程。它从根渲染器开始，该渲染器对应于HTML文档的<html>元素。布局通过某些或所有的框架层次结构递归进行，为需要几何信息的每个渲染器计算几何信息。

根渲染器的位置为0,0，其尺寸为视口–浏览器窗口的可见部分。所有渲染器都有一个“布局”或“回流”方法，每个渲染器都会调用其需要布局的子元素的布局方法。

为了避免在每次小改动时进行完整布局，浏览器使用了“脏位”系统。发生变化或添加的渲染器会将自身及其子元素标记为“脏位”：需要布局。有两个标志：“脏位”和“子元素脏位”，这意味着虽然渲染器本身可能没问题，但至少有一个子元素需要布局。

布局通常具有以下模式：

- 父渲染器确定自己的宽度。
- 父级遍历子元素并：
    - 放置子渲染器（设置其x和y）。
    - 如有需要，调用子布局–它们是脏的或者我们处于全局布局状态，或者由于其他原因–计算子的高度。
- 父级使用子元素的累积高度以及边距和填充的高度来设置自己的高度–这将由父渲染器的父级使用。
- 将其脏位设置为false。

此外，请注意，布局抖动是指在网页“加载”之前，Web浏览器必须多次重新流动或重绘网页。在JavaScript盛行之前，网站通常只会重新流动和绘制一次，但是现在越来越常见的是在页面加载时运行JavaScript，这可能会导致对DOM进行修改，从而导致额外的重新流动或重绘。根据重新流动的次数和网页的复杂性，可能会导致在加载页面时出现显著的延迟，特别是在低功率设备上，例如手机或平板电脑上。

## 绘画

在绘制阶段，遍历渲染树并调用渲染器的 "paint()" 方法以在屏幕上显示内容。绘制使用 UI 基础设施组件。

与布局一样，绘制也可以是全局的——整个树都会被绘制——或增量的。在增量绘制中，某些渲染器以不影响整个树的方式发生变化。更改的渲染器会使其在屏幕上的矩形失效。这会导致操作系统将其视为 "脏区域" 并生成 "绘制" 事件。操作系统会聪明地将几个区域合并为一个。

在重新绘制之前，WebKit 将旧矩形保存为位图。然后，它只绘制新旧矩形之间的差异。浏览器会尽量采取最小的可能操作来响应更改。因此，对元素颜色的更改只会导致该元素的重新绘制。对元素位置的更改将导致元素、其子元素和可能的兄弟元素的布局和重新绘制。添加DOM节点将导致节点的布局和重新绘制。主要更改，例如增加 "html" 元素的字体大小，将导致缓存失效、重新布局和重新绘制整个树。

有三种不同的定位方案：

* **普通：** 对象的定位根据其在文档中的位置。这意味着它在渲染树中的位置与其在DOM树中的位置相同，并根据其框类型和尺寸进行布局
* **浮动：** 对象首先按正常流进行布局，然后尽可能向左或向右移动
* **绝对：** 对象放置在渲染树中的位置与在DOM树中的位置不同

定位方案由 "position" 属性和 "float" 属性设置。

- static 和 relative 导致正常流动
- absolute 和 fixed 导致绝对定位

在静态定位中没有定义位置，使用默认定位。在其他方案中，作者指定位置：top、bottom、left、right。

**图层** 由 z-index CSS 属性指定。它表示盒子的第三维度：沿着 "z 轴" 的位置。

盒子被分成堆栈（称为堆叠上下文）。在每个堆栈中，后面的元素将首先绘制，前面的元素在顶部，更接近用户。如果重叠，最前面的元素将隐藏前面的元素。堆栈根据 z-index 属性排序。具有 "z-index" 属性的框组成本地堆栈。

## 相关资料

### 网络的诞生

蒂姆·伯纳斯-李（Tim Berners-Lee），一位在欧洲核子研究组织（CERN）工作的英国科学家，于1989年发明了万维网（WWW）。最初，万维网的构想和开发是为了满足世界各地大学和研究所科学家之间自动信息共享的需求。

CERN的第一个网站——也是世界上第一个网站——是专门为万维网项目而设，托管在伯纳斯-李的NeXT计算机上。该网站描述了万维网的基本特性；如何访问其他人的文档以及如何设置自己的服务器。NeXT机器——最初的Web服务器——仍然位于CERN。作为恢复[第一个网站](http://info.cern.ch/)项目的一部分，2013年，CERN将世界上第一个网站恢复到了其原始地址。

1993年4月30日，CERN将万维网软件置于公共领域。CERN通过公开许可证提供了下一个版本，以更可靠地最大程度地推广其传播。通过这些举措，使运行Web服务器所需的软件免费提供，以及提供[基本浏览器](http://line-mode.cern.ch/)和一系列代码库，使万维网得以蓬勃发展。

*更多阅读资料：*

[当您输入URL时，究竟发生了什么](http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/)

[浏览器是如何工作的：现代Web浏览器幕后运行原理](http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/)

[当您在浏览器中浏览网站时究竟发生了什么？](http://superuser.com/questions/31468/what-exactly-happens-when-you-browse-a-website-in-your-browser)

[发生了什么](https://github.com/alex/what-happens-when)

[那么浏览器究竟是如何渲染网站的](https://www.youtube.com/watch?v=SmE4OwHztCc)

[构建对象模型](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model)

[万维网如何运作：供新手网页开发者（或任何人）参考](https://medium.freecodecamp.com/how-the-web-works-a-primer-for-newcomers-to-web-development-or-anyone-really-b4584e63585c#.7l3tokoh1)